やりたいこと＝「spring-deposit を、multi-authentication の構成（Kong＋Keycloak＋BFF＋Redis＋React）にのせて、`savings-service`/`time-deposit-service` を `service-a`/`service-b` 相当として連携させる」ですよね。
以下の案は、**アプリ本体（2つの Spring Boot サービス）はそのまま**に、\*\*認証・認可は Keycloak、入口は Kong、ログイン／セッション管理と集約は BFF（Quarkus）\*\*という、multi-authentication と同じ流れに寄せたものです。

* spring-deposit の現状（ポート: `8081` と `8082`、サービス間は REST 連携）を踏まえています。([GitHub][1])
* 参照先構成（Kong が `/app/*` と `/api/*` を振り分け、BFF が Keycloak と OIDC、BFF が下流に Bearer を転送、Keycloak の realm を同梱）を踏襲します。([GitHub][2])

---

# 変更サマリ（全体像）

1. **ディレクトリ追加（spring-deposit リポの中に置く）**

```
spring-deposit/
├─ bff/                 # Quarkus BFF（multi-auth の quarkus-authz を流用/改名）
├─ frontend/            # React(Vite)（multi-auth の frontend を流用）
├─ kong/
│   ├─ kong.yml         # DB-LESS の宣言的設定（Service/Route）
│   └─ kong-nginx-http.conf
├─ realms/
│   └─ demo-realm.json  # Keycloak realm（ユーザ/ロール/クライアント定義）
├─ ops/
│   └─ docker-compose.stack.yaml  # すべてを一括で起動する compose
└─ savings-service/     # 既存（Spring）
└─ time-deposit-service/# 既存（Spring）
```

2. **Spring サービス（2つ）に「Keycloak の JWT 検証」を導入**
   `spring-boot-starter-oauth2-resource-server` を追加し、**BFF がヘッダで渡す Bearer を受け取って検証**。「必要ロール」の宣言でエンドポイントを保護。

3. **`time-deposit-service` → `savings-service` の内部呼び出しで Bearer を伝播**
   SecurityContext から取り出したトークンを **Authorization: Bearer ...** として転送。

4. **Kong（DB-LESS）**
   multi-auth と同様に `/app/*` → frontend、`/api/*`/`/login`/`/logout`/`/secure`/`/hello` → BFF にルーティング。([GitHub][2])

5. **Keycloak**
   `realms/demo-realm.json` を **自動インポート**。演習用ユーザとロール（例：`read`, `user`）を含め、BFF のクライアント（`quarkus-client`）を定義。([GitHub][2])

---

# 具体的な変更（コピペできる粒度）

## 1. Spring（両サービス共通）

### (a) 依存関係（`pom.xml`）

```xml
<dependency>
  <groupId>org.springframework.boot</groupId>
  <artifactId>spring-boot-starter-security</artifactId>
</dependency>
<dependency>
  <groupId>org.springframework.boot</groupId>
  <artifactId>spring-boot-starter-oauth2-resource-server</artifactId>
</dependency>
```

### (b) 設定（`src/main/resources/application.yml`）

Keycloak の realm に合わせる（compose の中では `http://keycloak:8080` で動かす想定）。

```yaml
server:
  port: 8081 # savings-service 側。time-deposit は 8082

spring:
  security:
    oauth2:
      resourceserver:
        jwt:
          issuer-uri: http://keycloak:8080/realms/demo-realm
          # または jwk-set-uri: http://keycloak:8080/realms/demo-realm/protocol/openid-connect/certs
```

### (c) 権限制御（`@EnableMethodSecurity` + `@PreAuthorize`）

```java
// SecurityConfig.java
@Configuration
@EnableMethodSecurity
public class SecurityConfig {

  @Bean
  SecurityFilterChain security(HttpSecurity http) throws Exception {
    http.csrf(csrf -> csrf.disable());
    http.authorizeHttpRequests(auth -> auth
        .requestMatchers("/actuator/**").permitAll()
        .anyRequest().authenticated()
    );
    http.oauth2ResourceServer(oauth -> oauth.jwt(jwt -> jwt
        .jwtAuthenticationConverter(grantedAuthoritiesExtractor())
    ));
    return http.build();
  }

  @Bean
  Converter<Jwt, ? extends AbstractAuthenticationToken> grantedAuthoritiesExtractor() {
    return jwt -> {
      Collection<GrantedAuthority> roles = Optional
          .ofNullable((Map<String, Object>) jwt.getClaims().get("realm_access"))
          .map(m -> (Collection<String>) m.get("roles"))
          .orElse(List.of())
          .stream()
          .map(r -> "ROLE_" + r) // Keycloak realm ロール → ROLE_xxx
          .map(SimpleGrantedAuthority::new)
          .toList();
      return new JwtAuthenticationToken(jwt, roles);
    };
  }
}
```

エンドポイント例：

```java
@PreAuthorize("hasRole('read')")
@GetMapping("/accounts/{id}")
public AccountDto get(@PathVariable UUID id) { ... }

@PreAuthorize("hasRole('user')")
@PostMapping("/accounts/{id}/deposit")
public BalanceDto deposit(@PathVariable UUID id, @RequestBody Amount a) { ... }
```

> multi-auth の例ユーザでは `testuser` に A/B の `read` と `user` を与えているため、同じロール命名を使うと流用が簡単です。([GitHub][2])

### (d) **トークン伝播**（`time-deposit-service` → `savings-service`）

Rest 呼び出しに **現在ユーザの Bearer** を付けて転送します。

```java
@Bean
WebClient webClient(WebClient.Builder builder) {
  return builder
      .filter((request, next) -> {
        Authentication auth = SecurityContextHolder.getContext().getAuthentication();
        if (auth instanceof JwtAuthenticationToken jwt) {
          return next.exchange(
              ClientRequest.from(request)
                  .headers(h -> h.setBearerAuth(jwt.getToken().getTokenValue()))
                  .build()
          );
        }
        return next.exchange(request);
      })
      .build();
}
```

呼び出し先 URL は compose のサービス名で解決（例：`http://savings-service:8081/accounts/{id}/withdraw`）。
spring-deposit の現行仕様（time-deposit が savings に REST 連携）に沿っています。([GitHub][1])

---

## 2. BFF（Quarkus、`spring-deposit/bff`）

* **multi-auth の `quarkus-authz` をほぼそのままコピー**し、**下流先のパスだけ置き換え**ます。

  * 旧：`/a/*` → **新：`/savings/*`**（`http://savings-service:8081`）
  * 旧：`/b/*` → **新：`/time/*`**（`http://time-deposit-service:8082`）
* BFF は **Keycloak と OIDC**（/api/login → /secure → /login → /app/ の流れ）を担当し、**取得したアクセストークンを下流に Bearer 転送**します（multi-auth と同じ思想）。([GitHub][2])
* 例：`/api/me`（ユーザ情報）、`/api/mashup`（2サービス結果のマージ）などはそのまま流用し、内部 URL を差し替えるだけで動作します。([GitHub][2])

---

## 3. Kong（DB-LESS、`spring-deposit/kong/kong.yml`）

multi-auth の構成をベースに、**BFF と Frontend だけを外に出す**（サービス本体は内部 NW）。([GitHub][2])

```yaml
_format_version: "3.0"
_transform: true

services:
  - name: api-svc
    host: bff        # ← コンテナ名（例：bff）
    port: 8080
    protocol: http
    routes:
      - name: api-route
        paths: ["/api"]
        strip_path: true
        preserve_host: true
        path_handling: v0
      - name: login-route
        paths: ["/login"]
        strip_path: false
        preserve_host: true
        path_handling: v0
      - name: logout-route
        paths: ["/logout"]
        strip_path: false
        preserve_host: true
        path_handling: v0
      - name: secure-route
        paths: ["/secure"]  # OIDC トリガ
        strip_path: false
        preserve_host: true
        path_handling: v0

  - name: frontend-dev
    host: frontend
    port: 5173
    protocol: http
    routes:
      - name: frontend-dev-route
        paths: ["/app", "/app/"]
        strip_path: false
        preserve_host: true
        path_handling: v1
```

> これは multi-auth の kong.yml と同じ考え方（DB-LESS、`KONG_DECLARATIVE_CONFIG` で読み込み）です。([GitHub][2])

> 補足：デバッグ用に `/savings` や `/time` を **Kong 経由で直接通す** route を追加し、Kong 側に JWT/OIDC プラグインを挿す構成も可能ですが、**BFF 経由の統一がシンプル**です。

---

## 4. Keycloak（`spring-deposit/realms/demo-realm.json`）

* **realm**: `demo-realm`
* **client**: `quarkus-client`（`http://localhost:8000/*` 等をリダイレクトに許可）
* **roles**: `read`, `user`（必要なら `savings_write`, `time_write` などを追加）
* **users**: 演習用に `testuser/password`（`read`,`user` 付与）…multi-auth の README と同趣旨。([GitHub][2])

compose 起動時に **自動インポート**されるようにします（`--import-realm`）。([GitHub][2])

---

## 5. Compose（すべてをまとめて起動、`ops/docker-compose.stack.yaml`）

```yaml
services:
  kong:
    image: kong:3.6.0
    environment:
      KONG_DATABASE: "off"
      KONG_DECLARATIVE_CONFIG: /usr/local/kong/declarative/kong.yml
      KONG_ADMIN_LISTEN: 0.0.0.0:8001
      KONG_NGINX_HTTP_INCLUDE: /usr/local/kong/nginx-http.conf
    ports: ["8000:8000","8001:8001"]
    volumes:
      - ../kong/kong.yml:/usr/local/kong/declarative/kong.yml:ro
      - ../kong/kong-nginx-http.conf:/usr/local/kong/nginx-http.conf:ro
    depends_on: [bff, frontend]
    networks: [appnet]

  keycloak:
    image: quay.io/keycloak/keycloak:25.0.2
    command: ["start-dev","--import-realm"]
    environment:
      KEYCLOAK_ADMIN: admin
      KEYCLOAK_ADMIN_PASSWORD: admin
    volumes:
      - ../realms:/opt/keycloak/data/import:ro
    ports: ["8080:8080"]
    networks: [appnet]

  redis:
    image: redis:7
    networks: [appnet]

  bff:
    build: ../bff
    environment:
      OIDC_AUTH_SERVER_URL: http://keycloak:8080/realms/demo-realm
      REDIS_HOST: redis
    expose: ["8080"]
    depends_on: [keycloak, redis, savings-service, time-deposit-service]
    networks: [appnet]

  frontend:
    build: ../frontend
    expose: ["5173"]
    networks: [appnet]

  savings-service:
    build: ../savings-service
    environment:
      SPRING_PROFILES_ACTIVE: docker
    expose: ["8081"]
    networks: [appnet]

  time-deposit-service:
    build: ../time-deposit-service
    environment:
      SPRING_PROFILES_ACTIVE: docker
    expose: ["8082"]
    networks: [appnet]

networks:
  appnet:
    driver: bridge
```

> Kong の DB-LESS 起動やルーティングの作法は multi-auth の README/例と一致させています。([GitHub][2])

---

# 動作確認手順（ローカル）

1. **ビルド**

   ```bash
   # Spring
   mvn -f savings-service clean package -DskipTests
   mvn -f time-deposit-service clean package -DskipTests

   # Quarkus
   mvn -f bff clean package -DskipTests

   # Frontend
   (cd frontend && npm ci && npm run build || true) # dev 起動なら build 不要
   ```

2. **起動**

   ```bash
   docker compose -f ops/docker-compose.stack.yaml up -d --build
   ```

3. **ブラウザ**

   * `http://localhost:8000/app/` にアクセス → **ログイン** → `/app/` に戻る（multi-auth と同じ UX）([GitHub][2])
   * BFF 経由 API（例：`/api/me`, `/api/mashup`）で **2サービスに対する権限有無**を確認。権限不足ならフロントで「権限エラー」を表示。([GitHub][2])

---

# 追加の設計メモ（安全性・実運用を見据えて）

* **トークンの時刻ズレ**：`spring.security.oauth2.resourceserver.jwt` に clock-skew を設定可。
* **ロール粒度**：まずは `read`/`user` の 2段で始め、将来 `savings_read`/`time_read` のように分割。
* **観測性**：Actuator（ヘルス）、OpenTelemetry（`traceparent` ヘッダ伝播）を検討。
* **Kong DB モード**：運用で宣言の同期を自動化したい場合は deck を使用（multi-auth README の注意点を参照）。([GitHub][2])
* **直接公開**：必要なら Kong に `/savings` `/time` の route を追加し、Kong 側で JWT/OIDC プラグインを有効にする（BFF バイパス）。

---

## 参考にした現状/仕様

* spring-deposit のサービス構成・ポート・API 概要。([GitHub][1])
* multi-authentication の全体アーキテクチャ、主要エンドポイント、Kong（DB-LESS）設定、Keycloak realm 自動インポートの運用。([GitHub][2])

---

必要なら、この案に沿った **具体的な差分 PR（ディレクトリ雛形・設定ファイル一式）** もこちらで用意して出せます。どこまで自動で組み込みたいか（BFF を別リポにする/同リポに入れる、ロールの名前付け方など）だけ教えてください。

[1]: https://github.com/h-i500/spring-deposit.git "GitHub - h-i500/spring-deposit"
[2]: https://github.com/h-i500/multi-authentication.git "GitHub - h-i500/multi-authentication"
