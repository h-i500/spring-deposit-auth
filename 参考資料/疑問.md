
# Keycloak クライアント設計の考え方
* **OAuth2/OIDC では「クライアントは直列（チェーン）しません」**。
  実際の経路は *HTTP の呼び先* が `balance-frontend → (プロキシ/バックエンド) → savings-service / time-deposit-service` となっても、**トークンは「ある1つのクライアント（＝ログイン元アプリ）」に対して発行**され、そのトークンをマイクロサービス群が検証するだけです。
* ですので、**フロント用の公開クライアントを1つ決める**のが正しく、残りは「そのトークンをどう検証するか（audience/roles/スコープ）」の話になります。

あなたのルート案：

```
balance-frontend → mashup-balance-inquiry-only → mashup-savings-term-deposits → savings-service/time-deposit-service
```

は、OAuth の概念に当てはめると

* `balance-frontend` … ブラウザで動く **公開クライアント（public + PKCE）**
* `mashup-balance-inquiry-only` … これも **公開クライアント（public + PKCE）** の想定
* `mashup-savings-term-deposits` … 既存 SPA 用クライアント（現在は public）**または** API（リソースサーバ）を代表する ID

のように見えますが、**クライアントを階層化して“中継”することはしません**。トークンは「どのクライアントでログインしたか（client\_id）」が埋め込まれ、API 側はそれを検証するだけです。

---



**きれいな設計**にするなら：

---

## おすすめ構成（本命）

1. **新しいフロント専用クライアント**を作る

   * クライアントID：`mashup-balance-inquiry-only`
   * 種別：**public**
   * **Standard Flow Enabled: ON**（= Authorization Code）
   * **PKCE: S256**
   * **Valid redirect URIs**: `http://localhost:3000/*`
   * **Web origins**: `http://localhost:3000`（または `+`）
   * 既定/任意スコープ：`profile`/`email`/`roles` など

2. **API 側が何を検証しているかで分岐**

   * ✦ **ロール検証のみ**（多くの Spring Resource Server のデフォルト）
     → アクセストークンに realm 役割 `read` などが入っていれば **client\_id が何でも通る**。
     → この場合は **何も追加設定不要**。新クライアントで発行されたトークンでも OK。

   * ✦ **audience（aud / resource）を厳格に見ている**、または Kong 側ポリシーが **特定クライアントIDに限定**
     → `mashup-balance-inquiry-only` で発行されたトークンに、**`mashup-savings-term-deposits` を audience として含める**必要があります。
     → Keycloak の **Audience Mapper** を使います。

     具体例（管理コンソール）：

     * Clients → `mashup-balance-inquiry-only` → **Client scopes**（または Mappers）→ **Add mapper** → **Audience**

       * **Included Client Audience**: `mashup-savings-term-deposits`
       * **Add to access token**: ON
         これで、**新クライアントでログインしても、トークンの `aud` に `mashup-savings-term-deposits` が入る**ため、既存 API/ゲートウェイのポリシーと整合します。

   * ✦ 「API を代表するクライアント」は本来 **bearer-only**（フロントでログインに使わない）にするのが定石
     → 既存 JSON だと `mashup-savings-term-deposits` が **public** になっており、「既存 SPA も同じクライアントを使う」構成です。
     → 将来的に整理するなら、**API 用は bearer-only / confidential、フロント用は public** に分け、**audience or scope** で結ぶのが王道です（今回は既存稼働を尊重して即動く形を優先）。

3. **Next.js 側は client\_id を差し替えるだけ**

   ```dotenv
   # .env.local
   KEYCLOAK_CLIENT_ID=mashup-balance-inquiry-only
   ```

   ほか（ISSUER/APP\_BASE\_URL/BACKEND\_BASE\_URL）はそのままでOK。
   ※ 既にご案内した `decodeJwtPayload` の **Buffer(base64url)** 対応は必須のままです。

---

## まとめ（判断基準）

* **最短で動かす**：
  既存 `mashup-savings-term-deposits` に **3000番の redirect/web origins を追加**して使う。
  → env の `KEYCLOAK_CLIENT_ID` はそのまま。

* **きれいに分離する（推奨）**：
  `mashup-balance-inquiry-only` を **新規作成**し、

  * API 側が **ロールのみ検証**ならそのまま使える
  * **audience 必須**なら **Audience Mapper** を追加して `aud: "mashup-savings-term-deposits"` を付与
    → env の `KEYCLOAK_CLIENT_ID` を新クライアントに変更。

どちらの道でも動かせます。
**「Kong/サービス側が何を条件に許可しているか（audience/roles/clientId）」** を一言いただければ、必要最小の Keycloak 設定差分をピンポイントで書き起こします（画面手順 / kcadm コマンド両方対応）。


---









* **audience（`aud` クレーム）**は「このアクセストークンは**どの受信者（API）向け**か」を示す識別子です。
* **いまの Kong 設定では audience を要求していません。**（`jwt` プラグインは署名と `exp` しか見ていません）
* したがって、**現状は Audience Mapper を入れなくても動きます**。将来「特定 API だけが受け付ける」厳格運用にしたい場合に audience を使います。

---

# audience とは？

OIDC/JWT の **`aud`（audience）** は、アクセストークンの**宛先**。
API 側（リソースサーバ）が「`aud` が自分宛か」を検証することで、**他サービス向けトークンの誤用を防止**できます。

例：`"aud": "mashup-savings-term-deposits"`
→ 「このトークンは `mashup-savings-term-deposits` 用」

---

# あなたの現在の Kong 設定の評価

抜粋：

```yaml
plugins:
  - name: jwt
    config:
      key_claim_name: iss
      run_on_preflight: false
      claims_to_verify: ["exp"]
```

* `jwt` プラグインは **`exp`（期限）** だけ検証。`aud` 検証の設定はありません。
  （このプラグインは `aud` を検証する機構を持たず、`claims_to_verify` で扱えるのは `exp`/`nbf`/`iat` 程度）
* `key_claim_name: iss` で **発行者（`iss`）に応じた鍵**を選んで署名検証しているだけです。

➡ **Kong は audience を要求していません。**
➡ よって **`mashup-balance-inquiry-only` クライアントを新規作成するだけで動作**します（Audience Mapper 不要）。

---

# 「audience を要求しているか」を調べる方法

1. **Kong ゲートウェイ側を確認**

   * 使っているのが **`jwt` プラグイン**なら → ほぼ**未検証**（`aud`は見ていない）。
   * **`openid-connect` プラグイン**（企業版やコミュニティ実装で存在）なら、設定に **required\_audiences / scopes** 等があるか確認。
   * いずれにせよ、**設定 YAML に `aud` をチェックする記述がなければ要求していません。**

2. **バックエンド（Spring/Spring Security）を確認**

   * `spring.security.oauth2.resourceserver.jwt` の設定で

     * `audiences`（Spring Boot 3 以降の一部スターター / もしくはカスタム Validator）
     * あるいはコードで `JwtClaimValidator<List<String>>("aud", ...)` などの**カスタムバリデータ**
       が入っていれば **API 側で audience を要求**しています。
   * それらが無ければ、API 側も `aud` を見ていない可能性が高いです。

3. **実トークンの `aud` を見る**（現在どう出ているか確認用）

   * ブラウザでログイン後、サーバログやデバッグでアクセストークンを一時出力し、
     `jwt.io` 等で中身を確認（`aud` フィールドが空/無しなら付与されていない）。
   * Keycloak の **Token Introspection** でも確認可能（管理者権限が必要）。

---

# 「きれいに分離」する時の実装指針

## 今すぐ動かす（audience 未使用）

* 新規クライアント **`mashup-balance-inquiry-only`**（public / Standard Flow / PKCE=S256）を作成

  * `redirectUris`: `http://localhost:3000/*`
  * `webOrigins`: `http://localhost:3000`（または `+`）
* Next.js の `.env.local` の `KEYCLOAK_CLIENT_ID` を `mashup-balance-inquiry-only` に。
* **Kong は現状のままで OK**（jwt 署名 + 期限のみの検証）。

## 将来、audience を**厳格化**したくなったら

* **Keycloak 側**：`mashup-balance-inquiry-only` に **Audience Mapper** を追加して
  **`included.client.audience = mashup-savings-term-deposits`** を付与（access token に `aud` を入れる）。
* **ゲートウェイ側**（選択肢）：

  * **Kong** を audience 検証できるプラグインに変更/追加（`openid-connect` などで `required_audiences` を指定）。
  * もしくは **カスタムプラグイン**で `aud` をチェック。
* **API 側**：Spring Security に **audience バリデータ**を追加。

---

# まとめ（今のあなたの環境での答え）

* **audience ＝ トークンの宛先（対象 API）を表すクレーム**。
* **あなたの `kong.yml` では audience を要求していません**（`jwt` プラグインは `aud` 未検証）。
* よって、**新クライアント `mashup-balance-inquiry-only` を作って切り替えるだけで OK**。
* もし将来「この API にはこのトークンだけ」という厳格化をしたい場合は、
  **Keycloak（Audience Mapper）＋ Kong/API 側の `aud` 検証**を足してください。

必要なら、**Audience Mapper の追加手順**や、**Kong 側で audience を強制する設定例**（どのプラグインを使うか前提にして）を書き起こします。
